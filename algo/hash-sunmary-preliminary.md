哈希問題的小結：基礎
====
我個人理解和分析哈希問題，主要是從以下四個角度來分析：

 1. 哈希函數的構造
 2. 哈希衝突的解決
 3. 數據結構的實現
 4. 哈希性能的分析

#哈希函數的構造
----
一般地，哈希函數的標準主要有兩個：

 - 簡單。其實主要就是要保證，對於輸入的key，能在O(1)的時間內計算出Hash值，理論上是O(1)，常數項上也不要太打折扣。

 - 均勻。這就合第二個問題關聯很大，均勻意味著衝突很少，這意味著性能的提高，衝突這個詞一聽就不是好詞~

我覺得好的哈希函數還是很具體問題相關的。假設我們知道關鍵字集合較為均勻的分佈在一個區間內，那麼直接定址法就會很管用，而且非常高效，一個例子就是Programming pearls裡面的電話號碼排序問題，其實就是計數排序。一般地，我們有以下常用的構造哈希函數的技術：

## 直接定址法

> Hash(key) = key + S, S即shift值.

這個問題舉個例子就是，咱知道key的範圍在[-10000, 10000]之間，於是開個20001大小的數組（哈希桶），任何key加上10000的偏移量就得到了其在哈希數組里的位置。

## 取餘法

> Hash(key) = key mod M. M為哈希桶的數量。

M的選擇通常為一個根據輸入集合大小而定的素數。素數是個好東西呀，設想M要是個合數，尤其要是約數還很多，再假設輸入集合中存在某個Key Q滿足：

gcd(M, Q) = d > 1, 即：M ＝ a * d, Q = b * d，可得:

> Q mod M = Q - M * ( Q / M) =  Q - M * ( b / a )

而 b / a 的範圍在[0, b]之間，這樣其實哈希的範圍已經不是設想的[0, M)了，衝突量就這麼又增加了，這個其實可以用隨機數測試來感受一下，我年紀大了就不玩了，以前試過~

## 基數轉換法

這個有點意思，就是把一個數字看成另一種進制的數字。比如，key = 236075，在13進制下為：2 * 13^5 + 3 * 13 ^ 4 + ... = 841547。

在選擇另一種進制時，當然還是要看數據範圍，不過一般原則還是儘量選擇一個和當前進制互質的進制。

#哈希衝突的解決
----
基本是兩類：

##開鏈法(Chaining)

這個是又好理解又好用，不多廢話，就是當發生衝突時，建立一個鏈表，衝突項append后鏈表尾巴上。以前在POJ還用這個辦法解決過問題，[POJ 2053](https://github.com/g7tianyi/my-acm-solutions/blob/master/poj/String/poj2503.cc).

## 开放寻址法(Open Addressing)

當衝突發生時，產生一個探查序列，檢索沿著這個序列進行。最簡單的產生探索序列的辦法自然就是線性掃描 ([linear probing](http://en.wikipedia.org/wiki/Linear_probing)了，即直接檢查下一個單元，偽代碼基本如下：
```
for i in [1, M):
begin
    pos = (hash(key) + i ) % M
    if pos has not been occupied:
    begin
        insert key in pos
        return true
    end
end
return false
```

當然，更“聰明點”的辦法是，探索序列也使用一個哈希函數，也就是Double Hashing，這些都是基本功。

#數據結構的實現
----
這個專門提出來說其實不合適，主要體會是兩條：

1. 怎麼存儲Hash關鍵字和對應的值域。數組是最容易想到的，但也有用平衡二叉樹的，這樣雖然不是O(1)了，但也有這麼玩的場合。
2. 哈希衝突的數據結構。比如開鏈時候的鏈表，有時候我們還可以用排序鏈表做優化；此外開鏈也可以二叉查找樹的，在哪個OJ上遇到過，但不記得什麼問題了，囧。

所以都是基本功的問題。

哈希當然也有CURD四類操作，again，還是基本功，我反正很一般...

#哈希性能的分析
----
略過。不然以我的水平，基本就是抄一遍《算法導論》或者馬叔叔的書了。

#應用舉例
----
- LeetCode [4Sum](https://github.com/g7tianyi/my-acm-solutions/blob/master/leetcode/4sum.cc)

*以後再補充，偶真忘了...*

