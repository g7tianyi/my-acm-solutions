Tarjan算法
=========
感谢
----
> 讲解很清晰 => http://noalgo.info/476.html

> 感谢提供习题集和参考思路 (直接打不开，只能贴Google Cache, Sorry~) => http://webcache.googleusercontent.com/search?q=cache:Z0crE7hGNPwJ:hi.baidu.com/foreverlin1204/item/090542f7f22578ca521c264f+&cd=1&hl=en&ct=clnk&gl=us

Tarjan算法基于后序DFS和并查集。算法从根节点root开始搜索，每次递归搜索所有子树，然后处理跟当前节点相关的所有查询。

算法用集合表示一类节点，这些节点跟集合外的点的LCA都一样，并把这个LCA设为这个集合的祖先。

1. 当搜索到节点x时，创建一个由x本身组成的集合，这个集合的祖先为x自己。
2. 然后递归搜索x的所有儿子节点,当一个子节点搜索完毕时，把子节点的集合与x节点的集合合并，并把合并后的集合的祖先设为x。
3. 因为这棵子树内的查询已经处理完，x的其他子树节点跟这棵子树节点的LCA都是一样的，都为当前根节点x。
4. 所有子树处理完毕之后，处理当前根节点x相关的查询。遍历x的所有查询，如果查询的另一个节点v已经访问过了，那么x和v的LCA即为v所在集合的祖先。

训练题
----
1. poj 1330 1470

2. poj 1986. 比上面两个稍微多了一个距离，但是本质还是一样的对于一个询问d[u,v]=dis[u]+dis[v]-dis[LCA(u,v)]， 可以一边LCA一边动态修改当前点到根的距离

3. poj 3728. 其实就是记录的东西多了一点（1）孩子到父亲最大价格（2）孩子到父亲最小价格（3）从自己到祖先的最大收益 （4）从祖先到自己的最大收益，这里的分情况讨论只需要手动的画下草图，在使用并查集的同时，做更新操作，维护上面提到的四个变量，对于一个查询，我们用爬山坡的方式保留最优值，这里画图会显的更为直观

4. poj 3694. 说实在的和LCA没有特别大的关系，就是DFS找割点，然后不是割点的点缩点，最后继续爬山坡，大概跑了1s多把，爬山坡顾名思义就是暴力的爬到祖先的意思

5. poj 3417 LCA+DP. 对于新添加的m条边，我们来考虑其两个端点在树上的路径，加入新边后，显然在树上产生了环，如果去掉新边，在从原树中删除任何一条，那么整个图的连通性就会被破坏，从这点出发我们来看最后添加完m条边后的图，对于一条树上的边，如果他多于1个环所包围，那么删除一条边时无法使得图不连通的，故问题转化成了统计每条树边被多少个环所包含，这里的统计需要用到树形DP，dp[x]表示从x到跟的边背环覆盖的次数，那么对于新添加的一条边（x,y）对统计结果的影响就是
    dp[x]++, dp[y]++,
    dp[lca(x,y)]-2,再来分析最终结果，对于被环包含为0的边，显然在图中是割边，那么删除它，然后从m条边中选择任意一条边都可以使徒步连通，对于被环包含一次的边，删除它，且删除环中且在m条边中的边就可以使边部连通，最后结果就是这两部分这里要注意的是，对于一个x=y的边，直接忽略它，我没加这句死活过不了

6. poj 3237 LCA+RMQ. 朴素的Tarjan应该也可以，把所有的查询预处理出来，但是写起来太烦了，正好借这个机会学习了RMQ的形式，先dfs将树化成欧拉序列，然后预处理rmq，对于取反，查询操作，同样采用爬山坡的方式，这样子问题就变的简单多了

7. poj 2763. 具体做法：首先对于0操作，可以看成是与前一个位置形成的查询对然后记录下来，接着做LCA，在做LCA的时候，利用dfs记录下时间戳，这样我们就获得了一个区间，这个区间的表示代表了一颗子树，当然这里是可以用一颗线段树来维护的在每次搜到一条边时，把这个边的权值插入到树状数组中，往根上加，表示从子节点到跟的距离，由于根的起始时间必然是1那么很显然的我们只需要把当前结点的终止时间出加入当前边的权值，又从这个点之前的那个时间段，删除，这样实际上的效果就是把一条边的权值插入了，这里想了很久，那么修改操作呢，同样的道理，这里的时间戳n起始代表的就是根，为什么呢，每次添加边调整的都是子树，由于dfs，最后更新的必定是1这棵树

8. 补充：hdu 3078，标准做法应该是LCA+treap+线段树，这里可以用爬山坡的方式水，用一个栈记录

